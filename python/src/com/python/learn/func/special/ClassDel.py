# Python __del__方法：销毁对象
#
# 与 __init__() 方法对应的是 __del__() 方法，__init__() 方法用于初始化 Python 对象，而 __del__() 则用于销毁 Python 对象，即在任何 Python 对
# 象将要被系统回收之时，系统都会自动调用该对象的 __del__() 方法。
#
# 当程序不再需要一个 Python 对象时，系统必须把该对象所占用的内存空间释放出来，这个过程被称为垃圾回收（GC，Garbage Collector），Python 会自动回收
# 所有对象所占用的内存空间，因此开发者无须关心对象垃圾回收的过程。
#
#  Python 采用自动引用计数（ARC）方式来回收对象所占用的空间，当程序中有一个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 1；当程序中
#  有两个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 2，依此类推，如果一个对象的引用计数变成了 0，则说明程序中不再有变量引用该对象，
#  表明程序不再需要该对象，因此 Python 就会回收该对象。
#
# 大部分时候，Python 的 ARC 都能准确、高效地回收系统中的每个对象。但如果系统中出现循环引用的情况，比如对象 a 持有一个实例变量引用对象 b，而对象 b 又
# 持有一个实例变量引用对象 a，此时两个对象的引用计数都是 1，而实际上程序已经不再有变量引用它们，系统应该回收它们，此时 Python 的垃圾回收器就可能没那么
# 快，要等专门的循环垃圾回收器（Cyclic Garbage Collector）来检测并回收这种引用循环。
#
# 当一个对象被垃圾回收时，Python 就会自动调用该对象的 __del__ 方法。需要说明的是，不要以为对一个变量执行 del 操作，该变量所引用的对象就会被回收，只有
# 当对象的引用计数变成 0 时，该对象才会被回收。因此，如果一个对象有多个变量引用它，那么 del 其中一个变量是不会回收该对象的。


class Item:
    def __init__(self, name, price):
        self.name = name
        self.price = price

    # 定义析构函数
    def __del__(self):
        print('del删除对象')


# 创建一个Item对象，将之赋给im变量
im = Item('鼠标', 29.8)
x = im  # ①
# 打印im所引用的Item对象
del im
print('--------------')

# 程序中重写了 Item 类的 __del__() 方法，该方法就是 Item 类的析构函数，当系统将要回收 Item 时，系统会自动调用 Item 对象的 __del__() 方法。
#
# 上面程序先创建了一个 Item 对象，并将该对象赋值给 im 变量，① 号代码又将 im 赋值给变量 x，这样程序中有两个变量引用 Item 对象，接下来程序执行
# del im 代码删除 im 对象，此时由于还有变量引用该 Item 对象，因此程序并不会回收 Item 对象。
#
# 最后需要说明的是，如果父类提供了 __del__() 方法，则系统重写 __del__() 方法时必须显式调用父类的 __del__() 方法，这样才能保证合理地回收父类实例的部分属性。
